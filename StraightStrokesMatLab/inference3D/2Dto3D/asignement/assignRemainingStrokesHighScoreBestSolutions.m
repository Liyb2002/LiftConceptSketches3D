function  [strokes_topology, intersections] = ...
        assignRemainingStrokesHighScoreBestSolutions(...
                        strokes_topology,...
                        intersections,...
                        cam_param,...
                        pairsInterInter)
                    
global confidence_threshold;
global max_cost_threshold;

inds_non_assigned_strks = ...
  find(cat(1,  strokes_topology(:).num_candidate_lines) > 0);

if isempty(inds_non_assigned_strks)
    return;
end


% Find the best costs and confidence values of the non assigned strokes:
max_costs = cat(1, strokes_topology(inds_non_assigned_strks).score);
confidence_vals = cat(1, strokes_topology(inds_non_assigned_strks).confidence);

% Sort the cost and confidence values:

[inds_non_assigned_strks,...
          max_costs, ...
          confidence_vals] = ...
                sortStrokesScoreConfidence(inds_non_assigned_strks,...
                                    max_costs, ...
                                    confidence_vals);
                                
% Process the strokes recursivly first crearting the solution with the
% highest score.
solution_number = selectSolution(strokes_topology, ...
                        intersections,...
                        inds_non_assigned_strks,...
                        max_costs,...
                        confidence_vals,...
                        0,...
                        cam_param,...
                        pairsInterInter);

    
  
end


function [inds_non_assigned_strks,...
          max_costs,...
          confidence_vals] = getRemainingNonAssignedStrokes(...
                inds_non_assigned_strks,...
                strokes_topology,...
                max_costs,...
                confidence_vals)
  

    inds_non_assigned_strks = ...
        find(cat(1,  strokes_topology(:).num_candidate_lines) > 0);

    max_costs = cat(1, strokes_topology(inds_non_assigned_strks).score);
    confidence_vals = cat(1, strokes_topology(inds_non_assigned_strks).confidence);
    
    [inds_non_assigned_strks,...
          max_costs, ...
          confidence_vals] = ...
                sortStrokesScoreConfidence(inds_non_assigned_strks,...
                                    max_costs, ...
                                    confidence_vals);
end

function solution_number = selectSolution(strokes_topology, ...
                        intersections,...
                        inds_non_assigned_strks,...
                        max_costs,...
                        confidence_vals,...
                        solution_number,...
                        cam_param,...
                        pairsInterInter)
    global folder_save;
    max_num_solutions = 10;
    
    if isempty(inds_non_assigned_strks) 
        folder_save_s = fullfile(folder_save, 'best_solutions');
        if ~exist(folder_save_s, 'dir')
            mkdir(folder_save_s);
        end
        filename = sprintf('highScore%.4d', solution_number);
        [strokes_topology, intersections, cam_param] = ...
            scaleAndCenterTheObject(strokes_topology, ...
                                    intersections, ...
                                    cam_param);
        
        saveDrawingAsOBJ(strokes_topology, intersections, folder_save_s, filename);
        saveDrawingAsOBJSingleObject(strokes_topology, folder_save_s, filename);
        saveJSONReconstruction(strokes_topology, intersections, cam_param, folder_save_s, filename);
        
        
        name = sprintf('highScore%04d_full', solution_number);
        rotate3DAndSaveSVGFrames(strokes_topology, cam_param, name);
        
        return;
    end
    
    ind_strk = inds_non_assigned_strks(1);
    strk_assign = strokes_topology(ind_strk);
    strk_assign.ind = ind_strk;

    UP_TO_LAST = true;
    [strk_assign.inds_intrsctns_eval,...
    strk_assign.inds_intrsctns_eval_actv,...
    strk_assign.inds_intrsctns_eval_mltpl_cnddts,...
    strk_assign.inds_intrsctng_strks_eval,...
    strk_assign.inds_intrsctng_strks_eval_actv,...
    strk_assign.inds_intrsctng_strks_eval_mltpl_cnddts] = ...
        returnIndicesNodesTypes(strk_assign, ...
                        cat(1, strokes_topology(:).depth_assigned),...
                                    intersections,...
                                    UP_TO_LAST);
                                        
    for i = 1:length(strokes_topology(ind_strk).candidate_lines)
        
        
   
                                    
        candidate_line = ...
            strokes_topology(ind_strk).candidate_lines(i);
        
        [strokes_topology_, intersections_] = ...
            assignDepthJointly(strokes_topology,...
                               intersections,...
                               cam_param,...
                               candidate_line,...
                               strk_assign,...
                               cat(1,candidate_line.configurations(:).p_full_joint),...
                               max(cat(1,candidate_line.configurations(:).p_full_joint)),...
                               pairsInterInter); 
      
       [inds_non_assigned_strks_,...
          max_costs_,...
          confidence_vals_] = getRemainingNonAssignedStrokes(...
                inds_non_assigned_strks,...
                strokes_topology_,...
                max_costs,...
                confidence_vals);
            
        
        solution_number = selectSolution(strokes_topology_, ...
                       intersections_,...
                       inds_non_assigned_strks_,...
                       max_costs_,...
                        confidence_vals_,...
                       solution_number,...
                       cam_param,...
                       pairsInterInter);
                   
       solution_number = solution_number+1;
       if solution_number > max_num_solutions
            return;
       end
        
    end
    solution_number = solution_number - 1;
end

