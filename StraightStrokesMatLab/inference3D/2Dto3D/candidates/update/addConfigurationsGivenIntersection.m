% function [candidate_line, intersections] = addConfigurationsGivenIntersection(...
%                                                 candidate_line,...
%                                                 primitive_geom,...
%                                                 line_length2D,...
%                                                 line_group,...
%                                                 intersections,...
%                                                 ind_inter,...       % new added intersections contributing to configuration
%                                                 ind_stroke_update,...
%                                                 ind_stroke,...      % new added stroke contributing to configuration
%                                                 ind_cnddt_ln)                               
%                                             
% 
% Description:
%   Creates new configuration by coping all exisiting ones and adding
%   additional possible intersection.

function [candidate_line, intersections] = addConfigurationsGivenIntersection(...
                                                candidate_line,...
                                                primitive_geom,...
                                                line_length2D,...
                                                line_group,...
                                                intersections,...
                                                strokes_topology,...
                                                ind_inter,...       % new added intersections contributing to configuration
                                                ind_stroke_update,...
                                                ind_stroke,...      % new added stroke contributing to configuration
                                                ind_cnddt_ln, ...
                                                candidate_lines)                               
                                            
    num_cnfgrtns = length(candidate_line.configurations);
    

    
   line_dir = candidate_line.dir;
    for i = 1:num_cnfgrtns
        if ismember(ind_inter, candidate_line.configurations(i).inds_intrsctns)
            continue;
        end
        
        configuration = candidate_line.configurations(i);
        %Create a new configurations with interection with newly added
        %stroke:
        inds_intrsctns = [configuration.inds_intrsctns ind_inter];
        p_intrsctns_distances =  [configuration.p_intrsctns_dists 1.0];
        
        [p_coverage,...
         inds_intrsctns,...
         p_intrsctns_distances] = ...
                computeCost2DCoverage(...
                    inds_intrsctns,...
                    p_intrsctns_distances, ...
                    intersections,...
                    primitive_geom,...
                    line_length2D);

         
  
       %% Add references to intersections with strokes with multiple candiate lines: 
       % If line had intersection with strokes with muliplte candidate
       % lines, new configuration should be added to the intersections
       % structure.
       
       try
            intersections = addConfigurationToMultCnddtsIntrsctns( ...
                configuration, ...
                intersections,...
                ind_cnddt_ln,...
                length(candidate_line.configurations)+1,...
                ind_stroke_update);                    
       catch e
            rethrow(e);
       end
       
     %% Add configuration into an intersection:
     if ~isfield(candidate_line, 'configurations')
        ind_cnfgrtn = 1;
    else
        ind_cnfgrtn = length(candidate_line.configurations) +1;
     end
    
    mhs = (intersections(ind_inter).strokes_indices == ind_stroke_update);    

    ind = find( intersections(ind_inter).cnddts3D(ind_cnddt_ln).cnddt_lns{mhs} == ind_cnddt_ln);
    if isempty(intersections(ind_inter).cnddts3D(ind_cnddt_ln).cnfgrtns{mhs})
        intersections(ind_inter).cnddts3D(ind_cnddt_ln).cnfgrtns{mhs}{1}(1) = ind_cnfgrtn;
    else
        intersections(ind_inter).cnddts3D(ind_cnddt_ln).cnfgrtns{mhs}{ind}(end+1) = ind_cnfgrtn;
    end
                             
       %% Add configuration:
       intersections__assigned = ...
           configuration.inds_intrsctns__assigned;
       
       intersections__mult_cnddts = ...
            [configuration.inds_intrsctns__mult_cnddts...
             ind_inter];
        
       intersections__mult_cnddts_ind = ...
            [configuration.inds_intrsctns__mult_cnddts_ind...
             ind_cnddt_ln];
         
        inds_jnts_strks =  ...
            [configuration.inds_jnts_strks ...
             ind_stroke];
         
%         [planes_normals_new,...
%          p_ortho,...
%          p_tangent,...
%          p_plane] = computePropertiesAtNewIntersection(line_dir,... direction of the stroke where the intersection is added
%                                                      candidate_lines, ...
%                                                      ind_inter,...
%                                                      ind_cnddt_ln,...
%                                                      line_group, ...
%                                                      intersections, ...
%                                                      ind_stroke,... % the newly added stroke
%                                                      strokes_topology);
        
%         planes_normals = ...
%              [configuration.planes_normals;...
%              planes_normals_new];
         
        planes_normals = ...
             [configuration.planes_normals];
%                 
%         if line_group == 4
% 
%            p_directional = configuration.p_directional;
%          
%         
%            p_directional = max([p_directional, p_ortho, p_tangent, p_plane]);
%            
%         else
%            p_directional = configuration.p_directional;
%         end
        
        p_directional = configuration.p_directional;

        p_full = costComposite(  p_coverage, ...
                                 p_directional,...
                                 line_group);
                                                     
         
        candidate_line = addIntersectionsConfigCandidateLine(...
                                candidate_line,...
                                inds_intrsctns,...
                                intersections__assigned,...
                                intersections__mult_cnddts,...
                                intersections__mult_cnddts_ind,...
                                inds_jnts_strks,...
                                p_intrsctns_distances,...
                                p_directional,...
                                p_coverage,...
                                p_full,...
                                planes_normals);
        
       
        
        
        
        
        
%         fprintf('ind_inter = %d, ind_cnddt_ln = %d \n', ind_inter, ind_cnddt_ln);
%         disp(intersections(ind_inter).cnddts3D(ind_cnddt_ln).cnfgrtns{mhs});
        
    end
    %candidate_line.max_cost = max(cat(1,candidate_line.configurations(:).p_full_joint));
end



function intersections = ...
            addConfigurationToMultCnddtsIntrsctns(configuration,...
                                                  intersections,...
                                                  ind_cnddt_ln,...
                                                  ind_new_cnfgrtn,...
                                                  ind_stroke_update)
% Since we just added a new comfiguration that repeats the intersections
% with strokes with multiple candidates, this configration should be added
% into the structure of the corresponding intersection.

for i = 1:length(configuration.inds_intrsctns__mult_cnddts)
    ind_intrsctn = configuration.inds_intrsctns__mult_cnddts(i);
    ind_cnddt = configuration.inds_intrsctns__mult_cnddts_ind(i);
    
    ind_pair = find(intersections(ind_intrsctn).strokes_indices == ind_stroke_update);
    
    mask = ismember(intersections(ind_intrsctn).cnddts3D(ind_cnddt).cnddt_lns{ind_pair}, ind_cnddt_ln);
    
    try
        intersections(ind_intrsctn).cnddts3D(ind_cnddt).cnfgrtns{ind_pair}{mask}(end+1) = ind_new_cnfgrtn;
    catch e
        rethrow(e);
    end
end

end