% function roughSketch3DInference(folder_designer, designer, object_name)
% 
% This function: 
%   separates the line strokes from the curved strokes (I).
%   estimates the vanishing points and probablility of the lines to converge towards these vanishing points (II).
%   passes this information to estimateIntersectionsProbabilistically() (III)

function roughSketch3DInference()
    close all;
    global SHOW_FIGS;
    global folder_save;
    global filepath_sketch_img;
    
    %% Intialise data structures:
    [  strokes_topology, ...
       intersections, ...
       cam_param ,...
       pairsInterInter,...
       ind_first_stroke] = ...
                intialiseDataStructures();
    

    saveJSONReconstruction(strokes_topology, intersections, cam_param, folder_save); 
 
    
    %% Reconstruct first stroke:
    
    cur_stroke = strokes_topology(ind_first_stroke);
    cur_stroke.ind = ind_first_stroke;
    
    UP_TO_LAST = true;
    [cur_stroke.inds_intrsctns_eval,...
     cur_stroke.inds_intrsctns_eval_actv,...
     cur_stroke.inds_intrsctns_eval_mltpl_cnddts,...
     cur_stroke.inds_intrsctng_strks_eval,...
     cur_stroke.inds_intrsctng_strks_eval_actv,...
     cur_stroke.inds_intrsctng_strks_eval_mltpl_cnddts] = ...
            returnIndicesNodesTypes(...
                    cur_stroke, ...
                    cat(1, strokes_topology(:).depth_assigned),...
                    intersections,...
                    UP_TO_LAST);

    if SHOW_FIGS
        img = readSketchImg(filepath_sketch_img);
        plot2DCurStrokeIntersectingStokes(...
            intersections, ...
            cur_stroke,...
            strokes_topology);
    else
        img = [];
    end
    
    try
    [strokes_topology(ind_first_stroke), ...
     intersections] = ...
            liftTo3DFirstStroke(...
                            strokes_topology(ind_first_stroke),...
                            intersections,...
                            cam_param, ...
                            img);
    catch e
        rethrow(e);
    end
    
    global last_added_stroke;
    last_added_stroke = ind_first_stroke;
    inds_strks_zero_cnddts = strokes_topology(ind_first_stroke).indcs_intrsctng_strks(...
        strokes_topology(ind_first_stroke).indcs_intrsctng_strks < ind_first_stroke);
    if ~isempty(inds_strks_zero_cnddts)
    try
        for ind_strk_zero_cnddts = reshape(inds_strks_zero_cnddts, 1, [])
              if (~isfield(strokes_topology(ind_strk_zero_cnddts), 'candidate_lines') || ...
                    isempty(strokes_topology(ind_strk_zero_cnddts).candidate_lines)) && ...
                    (~strokes_topology(ind_strk_zero_cnddts).depth_assigned) && ...
                    (ind_strk_zero_cnddts ~= last_added_stroke)

                  [strokes_topology, intersections] = ...
                       assignDepthStroke(strokes_topology,....
                                         intersections,...
                                         ind_strk_zero_cnddts, ...
                                         cam_param,...
                                         pairsInterInter,...
                                         true);
              end
        end    
    catch e
        rethrow(e);
    end
    end
    %% Reconstruct the rest of strokes:
    try
        [strokes_topology, ...
         intersections] = assignDepthStrokes( strokes_topology,....
                                                   intersections,...
                                                   ind_first_stroke,...
                                                   folder_save,...                                                                        
                                                   cam_param,...
                                                   pairsInterInter);
    catch e
        getReport(e, 'extended');
        rethrow(e);
    end                                                                

    

    
    assignRemainingStrokes(...
                        strokes_topology,...
                        intersections,...
                        cam_param,...
                        pairsInterInter);                    

    assignRemainingStrokesHighScore(...
                        strokes_topology,...
                        intersections,...
                        cam_param,...
                        pairsInterInter);
    
    
    saveDrawingAsOBJ(strokes_topology, intersections, folder_save, 'final');
    saveDrawingAsOBJSingleObject(strokes_topology, folder_save, 'final');
    saveJSONReconstruction(strokes_topology, intersections, cam_param, folder_save, 'final');     

    
%     [strokes_topology, intersections, cam_param] = scaleAndCenterTheObject(strokes_topology, intersections, cam_param, img);
% 
% 
%     
%     rotate3DAndSaveSVGFrames(strokes_topology, cam_param, 'final_full');
%     objectChangeFocalLengthAndSaveSVGFrames(strokes_topology, cam_param, 'focal_length_change');
%     objectChangeScaleOneAxisAndSaveSVGFrames(strokes_topology, cam_param, 'scaleXYZ');
    
    return;
    
    
    %% III. Precorrect perspective
% 
%     [intersections_2D,...
%     probabilities, ...
%     lines1inds,...
%     lines2inds] = computeIntersectionPoints(lines, img);
%     

    
% 
%     [lines, probabilitiesVP] = fixPerspectiveInitial(lines, VP, probabilitiesVP,...
%                             intersections_2D, lines1inds, lines2inds, ...
%                             img, ...
%                             designer, object_name,folder_save);
%    

    
    %% Perfrom grouping of the nodes:   

    
%     lines = fixVPdirectionsNodes(lines, VP, probabilitiesVP(ind_lines,:), points, lines1inds, lines2inds, img);
%     lines = fixVPdirectionsNodesSeparateIteration(lines, VP, probabilitiesVP(ind_lines,:),...
%                 points, lines1inds, lines2inds, img, designer, object_name);
%     lines = fixVPdirectionsHardConstraints(lines, VP, probabilitiesVP(ind_lines,:),...
%                 points, lines1inds, lines2inds, img, designer, object_name);
    
%     labelling = MRF(points);
       
end





